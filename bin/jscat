var GetOpt = require('ringo/args');
var fs = require('fs');

GetOpt.parser = new GetOpt.Parser();
GetOpt.parser
    .addOption('o', 'outfile', 'outfile', '')
    .addOption('I', 'include-dir', 'dir', '')
    .addOption('v', 'verbose', null, 'verbose mode')
    //.addOption('H', '', null, 'print the name of each included file')
    .addOption('P', 'inhibit-linemarkers', '', '')
    .addOption('C', 'keep-comments', null, 'do not discard comments')
    .addOption('h', 'help', null, 'print help');

GetOpt.options = GetOpt.parser.parse(system.args.splice(1), {
  outfile: 'out.js',
  includeDir: fs.workingDirectory(),
  verbose: false,
  inhibitLinemarkers: false,
  keepComments: false,
  help: false
});

if (GetOpt.options.help) {
  print('jscat [options] \n' + GetOpt.parser.help());
  system.exit(0);
}

var includeDirs = [GetOpt.options.includeDir];
var sources = fs.listTree(includeDirs[0]);
sources = sources.filter(function(file) {
  return fs.extension(file) == '.js';
});
if (includeDirs[0] !== fs.workingDirectory()) {
  sources = sources.map(function(path) {
    return fs.join(includeDirs[0], path);
  });
}

var require_re = /require\s*\(\s*[\'\"](\S*)[\'\"]\s*\)\s*;?/;
var include_re = /include\s*\(\s*[\'\"](\S*)[\'\"]\s*\)\s*;?/;

var out = fs.open(GetOpt.options.outfile, 'w'), outLineNum = 1;
var processed = [];
var orderedSources = [];

function l_require (path) {
  if (processed.some(function (p) { return this == p; }, path)) return;
  processed.push(path);

  var file = fs.open(path);

  var line = null, lineNum = 1;
  var match = null;

  for (line in file) {
    match = require_re.exec(line);
    if (match) {

      // if the file is not in the working directory
      // search for it in the include directories
      var tmp = match[1], j = 0;
      while (!fs.exists(tmp)) {
        tmp = fs.join(includeDirs[j], match[1]);
        j = j + 1;

        // if we fail to find the file print an error
        // and bail
        if (j > includeDirs.length) {
          print(fs.base(path) + ':' + lineNum + ': ' + fs.base(tmp) + ': No such file');
          system.exit(1);
        }
      }

      l_require(tmp);
    }

    lineNum = lineNum + 1;
  }

  if (orderedSources.every(function (s) { return this != s.path; }, path)) {
    orderedSources.push({path:path, length:lineNum});
  }
}

for (var i = 0; i < sources.length; i++) {
  if (GetOpt.options.verbose) {
    print(sources[i]);
  }

  l_require(sources[i]);
}

for (var i = 0; i < orderedSources.length; i++) {
  var path = orderedSources[i].path;
  var file = fs.open(path);
  var line = null;

  if (!GetOpt.options.inhibitLinemarkers) {
    out.writeLine('// begin: ' + path);
  }

  for (line in file) {
    if (require_re.exec(line)) line = '';
    out.writeLine(line);
  }

  if (!GetOpt.options.inhibitLinemarkers) {
    out.writeLine('// end: ' + path);
  }
}
